<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>PARC Library: /Users/gscott/Documents/workspace/CCNx_Distillery/src/Libparc/parc/algol/parc_Buffer.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">PARC Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7f9df3ca38d861d94088e98ccd293ed1.html">Libparc</a></li><li class="navelem"><a class="el" href="dir_32724a6363975856e5331f5a8cd1be3e.html">parc</a></li><li class="navelem"><a class="el" href="dir_93537ef564b672990ae767cc40b664ef.html">algol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parc_Buffer.h File Reference<div class="ingroups"><a class="el" href="group__memory.html">Memory and Buffer Management</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An indexable, linear buffer of bytes.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An indexable, linear buffer of bytes. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved.</dd></dl>
<p>A <code>PARCBuffer</code> is a linear, finite sequence of bytes. The essential properties of a buffer are its content, its capacity, limit, and position:</p>
<p> 
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xl="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" version="1.1" viewBox="48 143 304 126" width="304pt" height="126pt">
<defs>
<font-face font-family="Helvetica Neue" font-size="10" panose-1="2 0 5 3 0 0 0 2 0 4" units-per-em="1000" underline-position="-100" underline-thickness="50" slope="0" x-height="517" cap-height="714" ascent="951.99585" descent="-212.99744" font-weight="500">
<font-face-src>
<font-face-name name="HelveticaNeue"/>
</font-face-src>
</font-face>
<marker orient="auto" overflow="visible" markerUnits="strokeWidth" id="FilledArrow_Marker" viewBox="-1 -4 10 8" markerWidth="10" markerHeight="8" color="black">
<g>
<path d="M 8 0 L 0 -3 L 0 3 Z" fill="currentColor" stroke="currentColor" stroke-width="1"/>
</g>
</marker>
</defs>
<g stroke="none" stroke-opacity="1" stroke-dasharray="none" fill="none" fill-opacity="1">
<title>icon_512x512</title>
<rect fill="white" width="512" height="512"/>
<g>
<title>Layer 1</title>
<text transform="translate(73 231.5)" fill="black">
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x=".055" y="10" textLength="13.37">Off</tspan>
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x="13.425" y="10" textLength="13.52">set</tspan>
</text>
<text transform="translate(178.5 231)" fill="black">
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x=".445" y="10" textLength="36.11">Position</tspan>
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x="7.2" y="22" textLength="22.6">Mark</tspan>
</text>
<text transform="translate(294 231.5)" fill="black">
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x=".16" y="10" textLength="21.68">Limit</tspan>
</text>
<text transform="translate(271 157.5)" fill="black">
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x=".185" y="10" textLength="39.63">Capacity</tspan>
</text>
<text transform="translate(83 157.5)" fill="black">
<tspan font-family="Helvetica Neue" font-size="10" font-weight="500" x=".245" y="10" textLength="23.51">Array</tspan>
</text>
<path d="M 78 165.48333 C 73.6671 165.98884 67.757544 163.49623 65 167 C 63.49089 168.91749 62.925312 172.63153 62.52875 176.66717" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<rect x="59" y="187" width="281" height="13" fill="#205469"/>
<rect x="59" y="187" width="281" height="13" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<path d="M 316 166.11628 C 321.9994 166.74412 330.42197 164.60163 334 168 C 335.8631 169.76954 336.41326 173.04195 336.67595 176.64326" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<rect x="116" y="181" width="160" height="27" fill="#f60"/>
<rect x="116" y="181" width="160" height="27" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<path d="M 105 234.05085 C 108.6663 233.3673 114.16685 236.34137 116 232 C 117.15073 229.27477 116.856755 223.66586 116.47841 217.88884" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<path d="M 289 235.56897 C 284.6671 235.04603 278.16645 238.59437 276 234 C 274.57827 230.98495 275.02256 224.46193 275.496 217.88448" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<line x1="173.5" y1="232.84568" x2="125.08789" y2="211.92687" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
<line x1="220.5" y1="232.58861" x2="266.94855" y2="212.01014" marker-end="url(#FilledArrow_Marker)" stroke="black" stroke-linecap="round" stroke-linejoin="round" stroke-width="1"/>
</g>
</g>
</svg>
</p>
<ul>
<li>A buffer's capacity is the number of bytes it contains. The capacity of a buffer is never negative and never changes.</li>
<li>A buffer's limit is the index of the first byte that should not be read or written. A buffer's limit is never negative and is never greater than its capacity.</li>
<li>A buffer's position is a cursor to or index of the next byte to be read or written. A buffer's position is never negative and is never greater than its limit.</li>
</ul>
<p>A PARCBuffer's capacity may be larger than the extent of data manipulated by the buffer. The extent of the data manipulated by the buffer is manipulated via:</p><ul>
<li><a class="el" href="parc___buffer_8h.html#a52a85ffe6874ba6e7949898b094dd26d">parcBuffer_Position</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#aa4bccdf0131a9f4493fe11b6f192be3c">parcBuffer_SetPosition</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#a85355bd12b92ccf5d867d6435336c2ee">parcBuffer_Limit</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#a305130cc27400d15adef57c70b64b9af">parcBuffer_SetLimit</a> and</li>
<li><a class="el" href="parc___buffer_8h.html#a749088a5f36142c43cb6041ed14b846d">parcBuffer_Flip</a>.</li>
</ul>
<p>Strictly speaking, these relations are always true: <em>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</em></p>
<p>The general model for use is to:</p><ul>
<li>Create a buffer using a form of <a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9">parcBuffer_Allocate</a> or <a class="el" href="parc___buffer_8h.html#aefdd97017344b5e2b5ccfe3e37b53b46">parcBuffer_Wrap</a>.</li>
<li>Optionally insert data into the buffer via put operations, ultimately setting the position at the end of the valid data.</li>
<li>'Flip' the buffer using the <a class="el" href="parc___buffer_8h.html#a749088a5f36142c43cb6041ed14b846d">parcBuffer_Flip</a> function to set the position to 0 and the limit at the end of the valid data.</li>
<li>Optionally get data from the buffer via one of the many get operations.</li>
<li>Use <a class="el" href="parc___buffer_8h.html#acc01b3184924ff1886b2287c19da53b6">parcBuffer_Rewind</a> function to set the position to 0 again, leaving the limit at the end of the valid data.</li>
</ul>
<p>Data is placed into a <code>PARCBuffer</code> via <code>Put</code> functions, and retreived from the buffer via <code>Get</code> operations. Both <code>Put</code> and <code>Get</code> perform their operations at the position of the buffer and update the position to the location of the next element of data. Both <code>Put</code> and <code>Get</code> operations have a full compliment of intrinsic data types that operate on data at relative positions in the buffer.</p>
<p>The function <a class="el" href="parc___buffer_8h.html#a9eea1f9a5add6a5a51ad149e7d3357a8">parcBuffer_GetAtIndex</a> provides absolute index access to the buffer for bytes.</p>
<ul>
<li><a class="el" href="parc___buffer_8h.html#a7a38ecf146eebf75ed88b30a17a96627">parcBuffer_PutUint8</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#ac54f8ee661beddf170febf81887657e1">parcBuffer_PutUint16</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#ab65af61eb5e3949917ef29e0f8c831af">parcBuffer_PutUint32</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#aee33ab0cac93ea56e86882ce444c9199">parcBuffer_PutUint64</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#a4588f37d569f1f285e44381ed439ec16">parcBuffer_PutAtIndex</a></li>
<li><a class="el" href="parc___buffer_8h.html#a2ff41599fe427519ffdfa38d3205f21e">parcBuffer_GetUint8</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#a6de99d9af98ee0b702b129b7c53ad5cb">parcBuffer_GetUint16</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#af186a22aea5bb8130f96f30b413921ed">parcBuffer_GetUint32</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#aee6c57435c9268cf2915126382ff90ea">parcBuffer_GetUint64</a>,</li>
<li><a class="el" href="parc___buffer_8h.html#a9eea1f9a5add6a5a51ad149e7d3357a8">parcBuffer_GetAtIndex</a></li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Glenn Scott, Palo Alto Research Center (Xerox PARC) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;<a class="el" href="parc___object_8h_source.html">parc/algol/parc_Object.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="parc___byte_array_8h_source.html">parc/algol/parc_ByteArray.h</a>&gt;</code><br />
</div>
<p><a href="parc___buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1e97bc270003beae573e703339a5d526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e97bc270003beae573e703339a5d526"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>parcBuffer_OptionalAssertValid</b>(_instance_)&#160;&#160;&#160;<a class="el" href="parc___buffer_8h.html#ad9080a5fda6b714a188da44dd11655ff">parcBuffer_AssertValid</a>(_instance_)</td></tr>
<tr class="separator:a1e97bc270003beae573e703339a5d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a93ee1e678fbf74f67863180358c6d00d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ee1e678fbf74f67863180358c6d00d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>parcObjectDescriptor_Declaration</b> (PARCBuffer)</td></tr>
<tr class="separator:a93ee1e678fbf74f67863180358c6d00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9080a5fda6b714a188da44dd11655ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ad9080a5fda6b714a188da44dd11655ff">parcBuffer_AssertValid</a> (const PARCBuffer *instance)</td></tr>
<tr class="memdesc:ad9080a5fda6b714a188da44dd11655ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that an instance of <code>PARCBuffer</code> is valid.  <a href="#ad9080a5fda6b714a188da44dd11655ff">More...</a><br /></td></tr>
<tr class="separator:ad9080a5fda6b714a188da44dd11655ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4982ebb837072f6297bdf0e452deb34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ab4982ebb837072f6297bdf0e452deb34">parcBuffer_IsValid</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:ab4982ebb837072f6297bdf0e452deb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an instance of <code>PARCBuffer</code> is valid.  <a href="#ab4982ebb837072f6297bdf0e452deb34">More...</a><br /></td></tr>
<tr class="separator:ab4982ebb837072f6297bdf0e452deb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a651a26037477f8f855aebe9e5fce9"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9">parcBuffer_Allocate</a> (size_t capacity)</td></tr>
<tr class="memdesc:a26a651a26037477f8f855aebe9e5fce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCBuffer</code> using dynamically allocated memory.  <a href="#a26a651a26037477f8f855aebe9e5fce9">More...</a><br /></td></tr>
<tr class="separator:a26a651a26037477f8f855aebe9e5fce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd97017344b5e2b5ccfe3e37b53b46"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#aefdd97017344b5e2b5ccfe3e37b53b46">parcBuffer_Wrap</a> (void *array, size_t arrayLength, size_t position, size_t limit)</td></tr>
<tr class="memdesc:aefdd97017344b5e2b5ccfe3e37b53b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCBuffer</code> using using program supplied static memory (rather than allocated).  <a href="#aefdd97017344b5e2b5ccfe3e37b53b46">More...</a><br /></td></tr>
<tr class="separator:aefdd97017344b5e2b5ccfe3e37b53b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29390194f5e13b4f2480dfcc8173bc95"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a29390194f5e13b4f2480dfcc8173bc95">parcBuffer_WrapByteArray</a> (PARCByteArray *byteArray, size_t position, size_t limit)</td></tr>
<tr class="memdesc:a29390194f5e13b4f2480dfcc8173bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCBuffer</code> using referencing the given <a class="el" href="">PARCByteArray</a>.  <a href="#a29390194f5e13b4f2480dfcc8173bc95">More...</a><br /></td></tr>
<tr class="separator:a29390194f5e13b4f2480dfcc8173bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a2bbb81ceb7ce06dcbb7680a746cc"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ad49a2bbb81ceb7ce06dcbb7680a746cc">parcBuffer_WrapCString</a> (char *string)</td></tr>
<tr class="memdesc:ad49a2bbb81ceb7ce06dcbb7680a746cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of <code>PARCBuffer</code> wrapping the given null-terminated C string as its value.  <a href="#ad49a2bbb81ceb7ce06dcbb7680a746cc">More...</a><br /></td></tr>
<tr class="separator:ad49a2bbb81ceb7ce06dcbb7680a746cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d44673ff41676f75626360258754b5f"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a6d44673ff41676f75626360258754b5f">parcBuffer_AllocateCString</a> (const char *string)</td></tr>
<tr class="memdesc:a6d44673ff41676f75626360258754b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of a <code>PARCBuffer</code> copying the given null-terminated C string as its value.  <a href="#a6d44673ff41676f75626360258754b5f">More...</a><br /></td></tr>
<tr class="separator:a6d44673ff41676f75626360258754b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9acfd1991007fc32584a20d28dd450a"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ac9acfd1991007fc32584a20d28dd450a">parcBuffer_CreateFromArray</a> (const void *bytes, size_t length)</td></tr>
<tr class="memdesc:ac9acfd1991007fc32584a20d28dd450a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>PARCBuffer</code> initalised with a copy of the contents of given byte array.  <a href="#ac9acfd1991007fc32584a20d28dd450a">More...</a><br /></td></tr>
<tr class="separator:ac9acfd1991007fc32584a20d28dd450a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b765159d6d59ab7f103fefd5077e0a7"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a2b765159d6d59ab7f103fefd5077e0a7">parcBuffer_ParseHexString</a> (const char *hexString)</td></tr>
<tr class="memdesc:a2b765159d6d59ab7f103fefd5077e0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a null-terminated hexadecimal string to create a new <code>PARCBuffer</code> instance.  <a href="#a2b765159d6d59ab7f103fefd5077e0a7">More...</a><br /></td></tr>
<tr class="separator:a2b765159d6d59ab7f103fefd5077e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eda11163f5c5bcd1552588bd5a3c08"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a36eda11163f5c5bcd1552588bd5a3c08">parcBuffer_Resize</a> (PARCBuffer *buffer, size_t capacity)</td></tr>
<tr class="memdesc:a36eda11163f5c5bcd1552588bd5a3c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase or decrease the capacity of an existing PARCBuffer.  <a href="#a36eda11163f5c5bcd1552588bd5a3c08">More...</a><br /></td></tr>
<tr class="separator:a36eda11163f5c5bcd1552588bd5a3c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4826735b474484586ad83dd9a2244167"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a4826735b474484586ad83dd9a2244167">parcBuffer_Acquire</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a4826735b474484586ad83dd9a2244167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>PARCBuffer</code>.  <a href="#a4826735b474484586ad83dd9a2244167">More...</a><br /></td></tr>
<tr class="separator:a4826735b474484586ad83dd9a2244167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949677755415fd0448fa465004477951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a949677755415fd0448fa465004477951">parcBuffer_Release</a> (PARCBuffer **bufferPtr)</td></tr>
<tr class="memdesc:a949677755415fd0448fa465004477951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the specified instance, decrementing the reference count for the instance.  <a href="#a949677755415fd0448fa465004477951">More...</a><br /></td></tr>
<tr class="separator:a949677755415fd0448fa465004477951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4689cab3d3e731387f7845691249ae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a8b4689cab3d3e731387f7845691249ae">parcBuffer_Capacity</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a8b4689cab3d3e731387f7845691249ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this buffer's capacity.  <a href="#a8b4689cab3d3e731387f7845691249ae">More...</a><br /></td></tr>
<tr class="separator:a8b4689cab3d3e731387f7845691249ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5cce2a4b76a7d3d8e7cd73ac2b4021"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a8d5cce2a4b76a7d3d8e7cd73ac2b4021">parcBuffer_Clear</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a8d5cce2a4b76a7d3d8e7cd73ac2b4021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the given buffer restoring it to its initial state: The position is set to zero, the limit is set to the capacity, and the mark is invalidated.  <a href="#a8d5cce2a4b76a7d3d8e7cd73ac2b4021">More...</a><br /></td></tr>
<tr class="separator:a8d5cce2a4b76a7d3d8e7cd73ac2b4021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d239589beb1b92223765e9aeaa1cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#afa7d239589beb1b92223765e9aeaa1cc">parcBuffer_Equals</a> (const PARCBuffer *x, const PARCBuffer *y)</td></tr>
<tr class="memdesc:afa7d239589beb1b92223765e9aeaa1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>PARCBuffer</code> instances are equal.  <a href="#afa7d239589beb1b92223765e9aeaa1cc">More...</a><br /></td></tr>
<tr class="separator:afa7d239589beb1b92223765e9aeaa1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a636e9265ecd56bf4a27a81237a65c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a0a636e9265ecd56bf4a27a81237a65c1">parcBuffer_Compare</a> (const PARCBuffer *a, const PARCBuffer *b)</td></tr>
<tr class="memdesc:a0a636e9265ecd56bf4a27a81237a65c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares instance a with instance b for order.  <a href="#a0a636e9265ecd56bf4a27a81237a65c1">More...</a><br /></td></tr>
<tr class="separator:a0a636e9265ecd56bf4a27a81237a65c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246f94f9303005ea73a5d97809bee76"><td class="memItemLeft" align="right" valign="top">PARCByteArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a5246f94f9303005ea73a5d97809bee76">parcBuffer_Array</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a5246f94f9303005ea73a5d97809bee76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="">PARCByteArray</a> that backs this buffer.  <a href="#a5246f94f9303005ea73a5d97809bee76">More...</a><br /></td></tr>
<tr class="separator:a5246f94f9303005ea73a5d97809bee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf7597a9da3fbb4d0e6eaff1ba7e6a"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#acebf7597a9da3fbb4d0e6eaff1ba7e6a">parcBuffer_Copy</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:acebf7597a9da3fbb4d0e6eaff1ba7e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an independent copy the given <code>PARCBuffer</code>  <a href="#acebf7597a9da3fbb4d0e6eaff1ba7e6a">More...</a><br /></td></tr>
<tr class="separator:acebf7597a9da3fbb4d0e6eaff1ba7e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf14524a4403f6de60ea9b70b4d76f7d"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#acf14524a4403f6de60ea9b70b4d76f7d">parcBuffer_Duplicate</a> (const PARCBuffer *original)</td></tr>
<tr class="memdesc:acf14524a4403f6de60ea9b70b4d76f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new buffer that shares the original buffer's content.  <a href="#acf14524a4403f6de60ea9b70b4d76f7d">More...</a><br /></td></tr>
<tr class="separator:acf14524a4403f6de60ea9b70b4d76f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68677f35de30754c64b77940a00201"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a3c68677f35de30754c64b77940a00201">parcBuffer_ArrayOffset</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a3c68677f35de30754c64b77940a00201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset within this buffer's backing <a class="el" href="">PARCByteArray</a> of the first element.  <a href="#a3c68677f35de30754c64b77940a00201">More...</a><br /></td></tr>
<tr class="separator:a3c68677f35de30754c64b77940a00201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01b3184924ff1886b2287c19da53b6"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#acc01b3184924ff1886b2287c19da53b6">parcBuffer_Rewind</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:acc01b3184924ff1886b2287c19da53b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds this <code>PARCBuffer</code>: The position is set to zero and the mark is invalidated.  <a href="#acc01b3184924ff1886b2287c19da53b6">More...</a><br /></td></tr>
<tr class="separator:acc01b3184924ff1886b2287c19da53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6c54a186463fe41919b89ab92fa040"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a1d6c54a186463fe41919b89ab92fa040">parcBuffer_Reset</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a1d6c54a186463fe41919b89ab92fa040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the given <code>PARCBuffer</code>'s position to the previously-marked position.  <a href="#a1d6c54a186463fe41919b89ab92fa040">More...</a><br /></td></tr>
<tr class="separator:a1d6c54a186463fe41919b89ab92fa040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85355bd12b92ccf5d867d6435336c2ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a85355bd12b92ccf5d867d6435336c2ee">parcBuffer_Limit</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a85355bd12b92ccf5d867d6435336c2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given <code>PARCBuffer</code>'s limit.  <a href="#a85355bd12b92ccf5d867d6435336c2ee">More...</a><br /></td></tr>
<tr class="separator:a85355bd12b92ccf5d867d6435336c2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70834200bfdeb0f8aea80c49e7ad711e"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a70834200bfdeb0f8aea80c49e7ad711e">parcBuffer_Mark</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a70834200bfdeb0f8aea80c49e7ad711e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this buffer's mark at its position.  <a href="#a70834200bfdeb0f8aea80c49e7ad711e">More...</a><br /></td></tr>
<tr class="separator:a70834200bfdeb0f8aea80c49e7ad711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305130cc27400d15adef57c70b64b9af"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a305130cc27400d15adef57c70b64b9af">parcBuffer_SetLimit</a> (PARCBuffer *buffer, size_t newLimit)</td></tr>
<tr class="memdesc:a305130cc27400d15adef57c70b64b9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <code>PARCBuffer</code>'s limit.  <a href="#a305130cc27400d15adef57c70b64b9af">More...</a><br /></td></tr>
<tr class="separator:a305130cc27400d15adef57c70b64b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778b07f55801f73749b51fbff19e7f5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a778b07f55801f73749b51fbff19e7f5e">parcBuffer_Overlay</a> (PARCBuffer *buffer, size_t length)</td></tr>
<tr class="memdesc:a778b07f55801f73749b51fbff19e7f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to buffer memory starting the buffer's current position.  <a href="#a778b07f55801f73749b51fbff19e7f5e">More...</a><br /></td></tr>
<tr class="separator:a778b07f55801f73749b51fbff19e7f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a85ffe6874ba6e7949898b094dd26d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a52a85ffe6874ba6e7949898b094dd26d">parcBuffer_Position</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a52a85ffe6874ba6e7949898b094dd26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given <code>PARCBuffer</code>'s position.  <a href="#a52a85ffe6874ba6e7949898b094dd26d">More...</a><br /></td></tr>
<tr class="separator:a52a85ffe6874ba6e7949898b094dd26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bccdf0131a9f4493fe11b6f192be3c"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#aa4bccdf0131a9f4493fe11b6f192be3c">parcBuffer_SetPosition</a> (PARCBuffer *buffer, size_t newPosition)</td></tr>
<tr class="memdesc:aa4bccdf0131a9f4493fe11b6f192be3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given <code>PARCBuffer</code>'s position.  <a href="#aa4bccdf0131a9f4493fe11b6f192be3c">More...</a><br /></td></tr>
<tr class="separator:aa4bccdf0131a9f4493fe11b6f192be3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5507d0fcf5bb5671a6242d1ee102faa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#aa5507d0fcf5bb5671a6242d1ee102faa">parcBuffer_Remaining</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:aa5507d0fcf5bb5671a6242d1ee102faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements between the current position and the limit.  <a href="#aa5507d0fcf5bb5671a6242d1ee102faa">More...</a><br /></td></tr>
<tr class="separator:aa5507d0fcf5bb5671a6242d1ee102faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2d4a748cbad7386ee75373e0c442c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a3d2d4a748cbad7386ee75373e0c442c1">parcBuffer_HasRemaining</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a3d2d4a748cbad7386ee75373e0c442c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether there are any elements between the current position and the limit.  <a href="#a3d2d4a748cbad7386ee75373e0c442c1">More...</a><br /></td></tr>
<tr class="separator:a3d2d4a748cbad7386ee75373e0c442c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd525db9399f7f60512b58b5070aec1"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a3bd525db9399f7f60512b58b5070aec1">parcBuffer_Slice</a> (const PARCBuffer *original)</td></tr>
<tr class="memdesc:a3bd525db9399f7f60512b58b5070aec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new byte buffer whose content is a shared subsequence of this buffer's content.  <a href="#a3bd525db9399f7f60512b58b5070aec1">More...</a><br /></td></tr>
<tr class="separator:a3bd525db9399f7f60512b58b5070aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749088a5f36142c43cb6041ed14b846d"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a749088a5f36142c43cb6041ed14b846d">parcBuffer_Flip</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a749088a5f36142c43cb6041ed14b846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the limit to the current position, then set the position to zero.  <a href="#a749088a5f36142c43cb6041ed14b846d">More...</a><br /></td></tr>
<tr class="separator:a749088a5f36142c43cb6041ed14b846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eea1f9a5add6a5a51ad149e7d3357a8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a9eea1f9a5add6a5a51ad149e7d3357a8">parcBuffer_GetAtIndex</a> (const PARCBuffer *buffer, size_t index)</td></tr>
<tr class="memdesc:a9eea1f9a5add6a5a51ad149e7d3357a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single <code>uint8_t</code> at the index specified.  <a href="#a9eea1f9a5add6a5a51ad149e7d3357a8">More...</a><br /></td></tr>
<tr class="separator:a9eea1f9a5add6a5a51ad149e7d3357a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff41599fe427519ffdfa38d3205f21e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a2ff41599fe427519ffdfa38d3205f21e">parcBuffer_GetUint8</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a2ff41599fe427519ffdfa38d3205f21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the unsigned 8-bit value at the buffer's current position, and then increment the position by 1.  <a href="#a2ff41599fe427519ffdfa38d3205f21e">More...</a><br /></td></tr>
<tr class="separator:a2ff41599fe427519ffdfa38d3205f21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de99d9af98ee0b702b129b7c53ad5cb"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a6de99d9af98ee0b702b129b7c53ad5cb">parcBuffer_GetUint16</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a6de99d9af98ee0b702b129b7c53ad5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the unsigned 16-bit value in network order at the buffer's current position, and then increment the position by 2.  <a href="#a6de99d9af98ee0b702b129b7c53ad5cb">More...</a><br /></td></tr>
<tr class="separator:a6de99d9af98ee0b702b129b7c53ad5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af186a22aea5bb8130f96f30b413921ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#af186a22aea5bb8130f96f30b413921ed">parcBuffer_GetUint32</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:af186a22aea5bb8130f96f30b413921ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the unsigned 32-bit value in network order at the buffer's current position, and then increment the position by the 4.  <a href="#af186a22aea5bb8130f96f30b413921ed">More...</a><br /></td></tr>
<tr class="separator:af186a22aea5bb8130f96f30b413921ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6c57435c9268cf2915126382ff90ea"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#aee6c57435c9268cf2915126382ff90ea">parcBuffer_GetUint64</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:aee6c57435c9268cf2915126382ff90ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the unsigned 64-bit value in network order at the buffer's current position, and then increment the position by 8.  <a href="#aee6c57435c9268cf2915126382ff90ea">More...</a><br /></td></tr>
<tr class="separator:aee6c57435c9268cf2915126382ff90ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0314863d62e21cb46b6716e8004c0c60"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a0314863d62e21cb46b6716e8004c0c60">parcBuffer_GetBytes</a> (PARCBuffer *buffer, size_t length, uint8_t array[length])</td></tr>
<tr class="memdesc:a0314863d62e21cb46b6716e8004c0c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array of length bytes from the given PARCBuffer, copying them to an array.  <a href="#a0314863d62e21cb46b6716e8004c0c60">More...</a><br /></td></tr>
<tr class="separator:a0314863d62e21cb46b6716e8004c0c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a38ecf146eebf75ed88b30a17a96627"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a7a38ecf146eebf75ed88b30a17a96627">parcBuffer_PutUint8</a> (PARCBuffer *buffer, uint8_t value)</td></tr>
<tr class="memdesc:a7a38ecf146eebf75ed88b30a17a96627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an unsigned 8-bit value into the given <code>PARCBuffer</code> at the current position.  <a href="#a7a38ecf146eebf75ed88b30a17a96627">More...</a><br /></td></tr>
<tr class="separator:a7a38ecf146eebf75ed88b30a17a96627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f8ee661beddf170febf81887657e1"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ac54f8ee661beddf170febf81887657e1">parcBuffer_PutUint16</a> (PARCBuffer *buffer, uint16_t value)</td></tr>
<tr class="memdesc:ac54f8ee661beddf170febf81887657e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an unsigned 16-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order.  <a href="#ac54f8ee661beddf170febf81887657e1">More...</a><br /></td></tr>
<tr class="separator:ac54f8ee661beddf170febf81887657e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65af61eb5e3949917ef29e0f8c831af"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ab65af61eb5e3949917ef29e0f8c831af">parcBuffer_PutUint32</a> (PARCBuffer *buffer, uint32_t value)</td></tr>
<tr class="memdesc:ab65af61eb5e3949917ef29e0f8c831af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an unsigned 32-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order.  <a href="#ab65af61eb5e3949917ef29e0f8c831af">More...</a><br /></td></tr>
<tr class="separator:ab65af61eb5e3949917ef29e0f8c831af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee33ab0cac93ea56e86882ce444c9199"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#aee33ab0cac93ea56e86882ce444c9199">parcBuffer_PutUint64</a> (PARCBuffer *buffer, uint64_t value)</td></tr>
<tr class="memdesc:aee33ab0cac93ea56e86882ce444c9199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an unsigned 64-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order.  <a href="#aee33ab0cac93ea56e86882ce444c9199">More...</a><br /></td></tr>
<tr class="separator:aee33ab0cac93ea56e86882ce444c9199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4588f37d569f1f285e44381ed439ec16"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a4588f37d569f1f285e44381ed439ec16">parcBuffer_PutAtIndex</a> (PARCBuffer *buffer, size_t index, uint8_t value)</td></tr>
<tr class="memdesc:a4588f37d569f1f285e44381ed439ec16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert unsigned 8-bit value to the given <code>PARCBuffer</code> at given index.  <a href="#a4588f37d569f1f285e44381ed439ec16">More...</a><br /></td></tr>
<tr class="separator:a4588f37d569f1f285e44381ed439ec16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1619842a21cb0950adf20ee3037c80"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a6b1619842a21cb0950adf20ee3037c80">parcBuffer_PutArray</a> (PARCBuffer *buffer, size_t arrayLength, const uint8_t array[arrayLength])</td></tr>
<tr class="memdesc:a6b1619842a21cb0950adf20ee3037c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <code>arrayLength</code> bytes from the given array into the <code>PARCBuffer</code>.  <a href="#a6b1619842a21cb0950adf20ee3037c80">More...</a><br /></td></tr>
<tr class="separator:a6b1619842a21cb0950adf20ee3037c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc8eb050d9e4a645b5879b64b839af"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ab1dc8eb050d9e4a645b5879b64b839af">parcBuffer_PutCString</a> (PARCBuffer *buffer, const char *string)</td></tr>
<tr class="memdesc:ab1dc8eb050d9e4a645b5879b64b839af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given nul-terminated C string into a PARCBuffer, including the terminating nul byte.  <a href="#ab1dc8eb050d9e4a645b5879b64b839af">More...</a><br /></td></tr>
<tr class="separator:ab1dc8eb050d9e4a645b5879b64b839af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408ac2d024242c5b767c90e67a59bfc"><td class="memItemLeft" align="right" valign="top">PARCBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a7408ac2d024242c5b767c90e67a59bfc">parcBuffer_PutBuffer</a> (PARCBuffer *buffer, const PARCBuffer *source)</td></tr>
<tr class="memdesc:a7408ac2d024242c5b767c90e67a59bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the contents of a <code>PARCBuffer</code> into another.  <a href="#a7408ac2d024242c5b767c90e67a59bfc">More...</a><br /></td></tr>
<tr class="separator:a7408ac2d024242c5b767c90e67a59bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb189705a0d3dc40566a4bb715b4cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a0efb189705a0d3dc40566a4bb715b4cb">parcBuffer_HashCode</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a0efb189705a0d3dc40566a4bb715b4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code value for the given instance.  <a href="#a0efb189705a0d3dc40566a4bb715b4cb">More...</a><br /></td></tr>
<tr class="separator:a0efb189705a0d3dc40566a4bb715b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af039a47782e86ed75beb6f26ea670927"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#af039a47782e86ed75beb6f26ea670927">parcBuffer_FindUint8</a> (const PARCBuffer *buffer, uint8_t byte)</td></tr>
<tr class="memdesc:af039a47782e86ed75beb6f26ea670927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position of the first <code>uint8_t</code> value that matches the given byte.  <a href="#af039a47782e86ed75beb6f26ea670927">More...</a><br /></td></tr>
<tr class="separator:af039a47782e86ed75beb6f26ea670927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5724719ae25ca858ef0e7c47e617ceed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a5724719ae25ca858ef0e7c47e617ceed">parcBuffer_ToString</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a5724719ae25ca858ef0e7c47e617ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a null-terminated string representation of the specified <code>PARCBuffer</code> from the current position to the limit.  <a href="#a5724719ae25ca858ef0e7c47e617ceed">More...</a><br /></td></tr>
<tr class="separator:a5724719ae25ca858ef0e7c47e617ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf92bf3e11fb90fee53616775bb6cdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#abcf92bf3e11fb90fee53616775bb6cdd">parcBuffer_Display</a> (const PARCBuffer *buffer, int indentation)</td></tr>
<tr class="memdesc:abcf92bf3e11fb90fee53616775bb6cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a human readable representation of the given <code>PARCBuffer</code>.  <a href="#abcf92bf3e11fb90fee53616775bb6cdd">More...</a><br /></td></tr>
<tr class="separator:abcf92bf3e11fb90fee53616775bb6cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb71a7b5cdf2ebc65b16086aa978e668"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#acb71a7b5cdf2ebc65b16086aa978e668">parcBuffer_ToHexString</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:acb71a7b5cdf2ebc65b16086aa978e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a null-terminated string containing the hex-byte representation of the given <code>PARCBuffer</code>.  <a href="#acb71a7b5cdf2ebc65b16086aa978e668">More...</a><br /></td></tr>
<tr class="separator:acb71a7b5cdf2ebc65b16086aa978e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0d2b3e02b222e88ec7562ed56ca845"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a3c0d2b3e02b222e88ec7562ed56ca845">parcBuffer_SkipOver</a> (PARCBuffer *buffer, size_t length, const uint8_t bytesToSkipOver[length])</td></tr>
<tr class="memdesc:a3c0d2b3e02b222e88ec7562ed56ca845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the position of the given buffer to the first byte that is not in the array <code>bytesToSkipOver</code>.  <a href="#a3c0d2b3e02b222e88ec7562ed56ca845">More...</a><br /></td></tr>
<tr class="separator:a3c0d2b3e02b222e88ec7562ed56ca845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d5eaf856a13b0d3f6b85c9b6aec305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#af3d5eaf856a13b0d3f6b85c9b6aec305">parcBuffer_SkipTo</a> (PARCBuffer *buffer, size_t length, const uint8_t bytesToSkipTo[length])</td></tr>
<tr class="memdesc:af3d5eaf856a13b0d3f6b85c9b6aec305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the position of the given buffer to the first byte that is in the array <code>bytesToSkipTo</code>.  <a href="#af3d5eaf856a13b0d3f6b85c9b6aec305">More...</a><br /></td></tr>
<tr class="separator:af3d5eaf856a13b0d3f6b85c9b6aec305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298e0a6d38751e2f6e4adf077f6afb47"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a298e0a6d38751e2f6e4adf077f6afb47">parcBuffer_PeekByte</a> (const PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a298e0a6d38751e2f6e4adf077f6afb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the byte at the given <code>PARCBuffers'</code> current position, without modifying the position.  <a href="#a298e0a6d38751e2f6e4adf077f6afb47">More...</a><br /></td></tr>
<tr class="separator:a298e0a6d38751e2f6e4adf077f6afb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7890b44cd73634411efd02cc15afcccc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a7890b44cd73634411efd02cc15afcccc">parcBuffer_ParseHexNumber</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a7890b44cd73634411efd02cc15afcccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ASCII representation of a hexadecimal number in the given <code>PARCBuffer</code>  <a href="#a7890b44cd73634411efd02cc15afcccc">More...</a><br /></td></tr>
<tr class="separator:a7890b44cd73634411efd02cc15afcccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23fd12b6ae9cff7f1279e8aa3709569"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#ac23fd12b6ae9cff7f1279e8aa3709569">parcBuffer_ParseDecimalNumber</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:ac23fd12b6ae9cff7f1279e8aa3709569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ASCII representation of a unsigned decimal number in the given <code>PARCBuffer</code>  <a href="#ac23fd12b6ae9cff7f1279e8aa3709569">More...</a><br /></td></tr>
<tr class="separator:ac23fd12b6ae9cff7f1279e8aa3709569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711a4f4d3caf5ecc089054cae8ce118"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___buffer_8h.html#a9711a4f4d3caf5ecc089054cae8ce118">parcBuffer_ParseNumeric</a> (PARCBuffer *buffer)</td></tr>
<tr class="memdesc:a9711a4f4d3caf5ecc089054cae8ce118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ASCII representation of a unsigned decimal number or a hexadecimal number in the given <code>PARCBuffer</code>  <a href="#a9711a4f4d3caf5ecc089054cae8ce118">More...</a><br /></td></tr>
<tr class="separator:a9711a4f4d3caf5ecc089054cae8ce118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4826735b474484586ad83dd9a2244167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Acquire </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>PARCBuffer</code>. </p>
<p>Note that new <code>PARCBuffer</code> is not created, only that the given <code>PARCBuffer</code> reference count is incremented. Discard the reference by invoking <code>parcBuffer_Release</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *x = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCBuffer *x_2 = parcBuffer_Acquire(x);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;x);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_Release(&amp;x_2);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a26a651a26037477f8f855aebe9e5fce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCBuffer</code> using dynamically allocated memory. </p>
<p>The new buffer's position will be zero, its limit will be set to <code>length</code>, its mark will be undefined, and each of its elements will be initialized to zero.</p>
<p>If capacity is zero, the buffer contains no underlying byte array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Memory could not be allocated. </dd>
<dd>
non-NULL A pointer to a <code>PARCBuffer</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(64);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Release(&amp;&amp;buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6d44673ff41676f75626360258754b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_AllocateCString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of a <code>PARCBuffer</code> copying the given null-terminated C string as its value. </p>
<p>The new buffer's capacity will be the length of the string excluding the terminating nul character. its initial position will be 0, the index of the first byte that should not be read or written will be <code>limit</code>, and its mark will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>A pointer to C-string to copy and then wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCByteArray *buffer = parcBuffer_AllocateCString(&quot;test string&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBUffer_Release(&amp;buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5246f94f9303005ea73a5d97809bee76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCByteArray* parcBuffer_Array </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the <a class="el" href="">PARCByteArray</a> that backs this buffer. </p>
<p>If this <code>PARCBuffer</code> has a capacity of zero, there is no array of bytes and this function returns NULL.</p>
<p>Modifications to the contents of the <code>PARCByteArray</code> will visible to the given <code>PARCBuffer</code> and vice-versa.</p>
<p>The origin of the given <code>PARCBuffer</code> may not be the same as the origin of the underlying <code>PARCByteArray</code>. Use <a class="el" href="parc___buffer_8h.html#a3c68677f35de30754c64b77940a00201">parcBuffer_ArrayOffset</a> to obtain the origin of the given <code>PARCBuffer</code> relative to the origin of the underlying <code>PARCByteArray</code></p>
<p>The caller must obtain its own reference to the <code>PARCByteArray</code> if it intends to store it elsewhere.</p>
<p>Note: Many hard to find bugs can be caused by using this function. Use the functions provided to manipulate the <code>PARCBuffer</code> and its contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A <code>PARCBuffer</code> pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL There is no <code>PARCByteArray</code> backing the given <code>PARCBuffer</code> (no capacity). </dd>
<dd>
non-NULL The pointer to the <code>PARCByteArray</code> for the given <code>PARCBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCByteArray *array = parcBuffer_Array(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___byte_array_8h.html#a75334572d6fd023428bd46ae88e21570" title="Increase the number of references to a PARCByteArray. ">parcByteArray_Acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c68677f35de30754c64b77940a00201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_ArrayOffset </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset within this buffer's backing <a class="el" href="">PARCByteArray</a> of the first element. </p>
<p>Buffer position <em>p</em> corresponds to array index <em>p + arrayOffset()</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>size_t</code> The offset within this <code>PARCBuffer</code>'s array of the first element of the buffer</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    size_t arrayOffset = parcBuffer_ArrayOffset(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // offset will be 0 since the contents of the buffer start at the beginning</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad9080a5fda6b714a188da44dd11655ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcBuffer_AssertValid </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that an instance of <code>PARCBuffer</code> is valid. </p>
<p>If the instance is not valid, terminate via <code><a class="elRef" doxygen="/Users/gscott/Documents/workspace/CCNx_Distillery/build/Longbow/documentation/longbow.doctags:https://parc.github.io/LongBow/" href="https://parc.github.io/LongBow/traps_8h.html#aca23f46aa717be173e08b7fd0ce9d513">trapIllegalValue()</a></code></p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(64);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_AssertValid(array);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>parcBuffer_OptionalAssertValid </dd></dl>

</div>
</div>
<a class="anchor" id="a8b4689cab3d3e731387f7845691249ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_Capacity </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this buffer's capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given buffer's capacity.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    size_t capacity = parcBuffer_Capacity(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;capacity);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8d5cce2a4b76a7d3d8e7cd73ac2b4021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Clear </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the given buffer restoring it to its initial state: The position is set to zero, the limit is set to the capacity, and the mark is invalidated. </p>
<p>The mark is made invalid and any subsequent operation on the resulting <code>PARCBuffer</code> that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcBuffer_Clear(buffer);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0a636e9265ecd56bf4a27a81237a65c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parcBuffer_Compare </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares instance a with instance b for order. </p>
<p>Returns a negative integer, zero, or a positive integer as instance a is less than, equal to, or greater than instance b.</p>
<p>The buffer's position, limit, and mark are not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A pointer to the first instance of <code>PARCBuffer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A pointer to the second instance of <code>PARCBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 Instance a is less than instance b. </dd>
<dd>
0 Instance a and instance b compare the same. </dd>
<dd>
&gt;0 Instance a is greater than instance b.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *bufferA = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *bufferB = parcBuffer_Allocate(10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (parcBuffer_Compare(bufferA, bufferB) == 0) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        printf(&quot;Buffers are equal.\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;bufferA);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Release(&amp;bufferB);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#afa7d239589beb1b92223765e9aeaa1cc" title="Determine if two PARCBuffer instances are equal. ">parcBuffer_Equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acebf7597a9da3fbb4d0e6eaff1ba7e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Copy </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an independent copy the given <code>PARCBuffer</code> </p>
<p>A new buffer is created as a complete copy of the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Memory could not be allocated. </dd>
<dd>
non-NULL A pointer to a new <code>PARCBuffer</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCBuffer *copy = parcBuffer_Copy(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_Release(&amp;copy);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac9acfd1991007fc32584a20d28dd450a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_CreateFromArray </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>PARCBuffer</code> initalised with a copy of the contents of given byte array. </p>
<p>The length must be non-negative (&gt; 0) and the array pointer must not be NULL. The contents of the given array are used to initialize the <code>PARCBuffer</code> instance, and the size of the new instance is equal to the specified length (just wide enough to fit the array).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>A pointer to an array of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes to copy to the <code>PARCBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated <code>PARCBuffer</code> instance that must be freed via <code><a class="el" href="parc___buffer_8h.html#a949677755415fd0448fa465004477951" title="Release a previously acquired reference to the specified instance, decrementing the reference count f...">parcBuffer_Release()</a></code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    unsigned char array[] = { 1, 2, 3, 4, 5 };</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *buffer = parcBuffer_CreateFromArray(array, sizeof(array));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abcf92bf3e11fb90fee53616775bb6cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcBuffer_Display </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a human readable representation of the given <code>PARCBuffer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indentation</td><td>The level of indentation to use to pretty-print the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the instance to display.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *instance = parcBuffer_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Display(instance, 0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;instance);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acf14524a4403f6de60ea9b70b4d76f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Duplicate </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new buffer that shares the original buffer's content. </p>
<p>The content of the new buffer will be that of this buffer. Changes to the buffer's content will be visible in both buffers, however the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's capacity, limit, position, and mark values will be identical to those of the original buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>The orignal PARCBuffer instance that will be duplicated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Memory could not be allocated. </dd>
<dd>
non-NULL A pointer to ta valid <code>PARCBuffer</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_Duplicate(buffer2);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;buffer2);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afa7d239589beb1b92223765e9aeaa1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcBuffer_Equals </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>PARCBuffer</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>PARCBuffer</code> instances are maintained: *</p><ul>
<li>It is reflexive: for any non-null reference value x, <code>parcBuffer_Equals(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>parcBuffer_Equals(x, y)</code> must return true if and only if <code>parcBuffer_Equals(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>parcBuffer_Equals(x, y)</code> returns true and <code>parcBuffer_Equals(y, z)</code> returns true, then <code>parcBuffer_Equals(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>parcBuffer_Equals(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>parcBuffer_Equals(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>PARCBuffers</code> x and y are equal. </dd>
<dd>
false <code>PARCBuffers</code> x and y are not equal.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *bufferA = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *bufferB = parcBuffer_Allocate(10);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (parcBuffer_Equals(bufferA, bufferB)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        printf(&quot;Buffers are equal.\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    } else {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        printf(&quot;Buffers are NOT equal.\n&quot;);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    parcBuffer_Release(&amp;bufferA);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    parcBuffer_Release(&amp;bufferB);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a0efb189705a0d3dc40566a4bb715b4cb" title="Returns a hash code value for the given instance. ">parcBuffer_HashCode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af039a47782e86ed75beb6f26ea670927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_FindUint8 </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the position of the first <code>uint8_t</code> value that matches the given byte. </p>
<p>If the value does not exist between the current position and the limit, return <code>SIZE_MAX</code> (&lt;stdint.h&gt;).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>The byte to search for within the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first byte equal to <code>byte</code>, or <code>SIZE_MAX</code> (&lt;stdint.h&gt;)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Wrap(&quot;Hello World&quot;, 10, 0, 10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    size_t ePosition = parcBuffer_FindUint8(buffer, &#39;e&#39;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // ePosition is equal to 1.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    size_t xPosition = parcBuffer_FindUint8(buffer, &#39;x&#39;);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // ePosition is equal to SIZE_MAX.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a749088a5f36142c43cb6041ed14b846d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Flip </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the limit to the current position, then set the position to zero. </p>
<p>If the mark is defined, it is invalidated.</p>
<p>Any subsequent operation that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint8_t actual = parcBuffer_GetUint8(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9eea1f9a5add6a5a51ad149e7d3357a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parcBuffer_GetAtIndex </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single <code>uint8_t</code> at the index specified. </p>
<p>The buffer's position is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index into the <code>buffer</code> to find the <code>uint8_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint8_t</code> value at <code>index</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    uint8_t actual = parcBuffer_GetAtIndex(buffer, 0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    // actual == (uint8_t) &#39;X&#39;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0314863d62e21cb46b6716e8004c0c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_GetBytes </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>array</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an array of length bytes from the given PARCBuffer, copying them to an array. </p>
<p>The buffer's position is incremented by <code>length</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The pointer to the instance of <code>PARCBuffer</code> containing the <code>uint8_t</code> value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of <code>uint8_t</code> elements to get. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The <code>uint8_t</code> array to receive <code>length</code> bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the given <code>PARCBuffer</code> instance</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(5);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, &#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_PutUint8(buffer, &#39;B&#39;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_PutUint8(buffer, &#39;C&#39;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint8_t array[3];</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_GetBytes(buffer, 3, array);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // array[0] == &#39;A&#39;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // array[1] == &#39;B&#39;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // array[2] == &#39;C&#39;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a778b07f55801f73749b51fbff19e7f5e" title="Return a pointer to buffer memory starting the buffer&#39;s current position. ">parcBuffer_Overlay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6de99d9af98ee0b702b129b7c53ad5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t parcBuffer_GetUint16 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the unsigned 16-bit value in network order at the buffer's current position, and then increment the position by 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The pointer to the <code>PARCBuffer</code> instance containing the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint16_t</code> at the buffer's current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     (buffer, 0x1234);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint16_t actual = parcBuffer_GetUint16(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a778b07f55801f73749b51fbff19e7f5e" title="Return a pointer to buffer memory starting the buffer&#39;s current position. ">parcBuffer_Overlay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af186a22aea5bb8130f96f30b413921ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t parcBuffer_GetUint32 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the unsigned 32-bit value in network order at the buffer's current position, and then increment the position by the 4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The pointer to the instance of <code>PARCBuffer</code> containing the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint32_t</code> at the buffer's current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint32(buffer, 0x12345678);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint32_t actual = parcBuffer_GetUint32(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a778b07f55801f73749b51fbff19e7f5e" title="Return a pointer to buffer memory starting the buffer&#39;s current position. ">parcBuffer_Overlay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee6c57435c9268cf2915126382ff90ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t parcBuffer_GetUint64 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the unsigned 64-bit value in network order at the buffer's current position, and then increment the position by 8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The pointer to the instance of <code>PARCBuffer</code> containing the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint64_t</code> at the buffer's current position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint64(buffer, 0x12345678);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint64_t actual = parcBuffer_GetUint64(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a778b07f55801f73749b51fbff19e7f5e" title="Return a pointer to buffer memory starting the buffer&#39;s current position. ">parcBuffer_Overlay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff41599fe427519ffdfa38d3205f21e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parcBuffer_GetUint8 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the unsigned 8-bit value at the buffer's current position, and then increment the position by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The pointer to a <code>PARCBuffer</code> instance containing the <code>uint8_t</code> value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint8_t</code> at the buffer's current position</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Flip(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    uint8_t actual = parcBuffer_GetUint8(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0efb189705a0d3dc40566a4bb715b4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a> parcBuffer_HashCode </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code value for the given instance. </p>
<p>The hash code of a <code>PARCBuffer</code> depends only upon its remaining elements from the current position to the limit.</p>
<p>Because <code>PARCBuffer</code> hash codes are content-dependent, be careful when using them as keys in <code>PARCHashMap</code> and other similar data structures unless it is known that their contents will not change.</p>
<p>The general contract of <code>HashCode</code> is:</p>
<p>Whenever it is invoked on the same instance more than once during an execution of an application, the <code>HashCode</code> function must consistently return the same value, provided no information used in a corresponding <a class="el" href="parc___byte_array_8h.html#a1a00fbdf1c00c83a2a03f89c4b5c26c7">parcByteArray_Equals</a> comparisons on the instance is modified.</p>
<p>This value need not remain consistent from one execution of an application to another execution of the same application. If two instances are equal according to the <a class="el" href="parc___byte_array_8h.html#a1a00fbdf1c00c83a2a03f89c4b5c26c7">parcByteArray_Equals</a> method, then calling the <a class="el" href="parc___buffer_8h.html#a0efb189705a0d3dc40566a4bb715b4cb">parcBuffer_HashCode</a> method on each of the two instances must produce the same integer result.</p>
<p>It is not required that if two instances are unequal according to the <a class="el" href="parc___buffer_8h.html#afa7d239589beb1b92223765e9aeaa1cc">parcBuffer_Equals</a> function, then calling the <code>parcBuffer_HashCode</code> method on each of the two objects must produce distinct integer results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hashcode for the given instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint32_t hashValue = parcBuffer_HashCode(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___byte_array_8h.html#a89a7f447ffdd51183e9049caeac45673" title="Returns a hash code value for the given instance. ">parcByteArray_HashCode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d2d4a748cbad7386ee75373e0c442c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcBuffer_HasRemaining </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether there are any elements between the current position and the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The <code>PARCBuffer</code> contains at least one more element. </dd>
<dd>
false The <code>PARCBuffer</code> does not contain any more elements.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    bool hasRemaining = parcBuffer_HasRemaining(buffer); // returns true since #remaining = 5</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab4982ebb837072f6297bdf0e452deb34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcBuffer_IsValid </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an instance of <code>PARCBuffer</code> is valid. </p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The instance is valid. </dd>
<dd>
false The instance is not valid.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(64);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    if (parcBuffer_IsValid(buffer)) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        printf(&quot;Buffer is valid.\n&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a85355bd12b92ccf5d867d6435336c2ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_Limit </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given <code>PARCBuffer</code>'s limit. </p>
<p>A buffer's limit is the index of the first element that should not be read or written. A buffer's limit is never negative and is never greater than its capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code>'s limit.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    size_t limit = parcBuffer_Limit(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // limit will be 10</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a70834200bfdeb0f8aea80c49e7ad711e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Mark </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this buffer's mark at its position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Mark(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    // since the position was 0, the mark remains at 0</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a778b07f55801f73749b51fbff19e7f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* parcBuffer_Overlay </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to buffer memory starting the buffer's current position. </p>
<p>The <code>length</code> parameter must be less than or equal to the remaining bytes in the buffer and has no effect on the return value, except that if the buffer's position is equal to the limit, then this traps with OutOfBounds</p>
<p>The current position of the buffer is advanced by <code>length</code> bytes. It is acceptable for the <code>length</code> parameter to be zero, thereby causing the current position to remain unchanged.</p>
<p>This does not guarantee any particular memory alignment. Therefore, it is possible to obtain a pointer to memory that cannot be accessed as a native type because of CPU architecture alignment requirements.</p>
<p>The function returns a pointer to contiguous memory within a <code>PARCBuffer</code>, but does not acquire a reference to the <code>PARCBuffer</code> instance, the underlying <a class="el" href="">PARCByteArray</a>, nor the actual memory array. If the <a class="el" href="">PARCBuffer</a> or the underlying <a class="el" href="">PARCByteArray</a> is released finally, the result from a previous call to <code>parcBuffer_Overlay</code> will point to undefined values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes to advance the buffer's position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to memory.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *expected = &quot;Hello World&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    struct timeval theTime = { .tv_sec = 123, .tv_usec = 456};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(sizeof(uint16_t) + strlen(expected) + sizeof(theTime));</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_PutUint16(buffer, strlen(expected));</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcBuffer_PutUint8(buffer, expected, strlen(expected));</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_PutUint8(buffer, &amp;theTime, sizeof(theTime));</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcBuffer_Flip();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    uint16_t length = parcBuffer_GetUint16(buffer);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    char *actual = parcBuffer_Overlay(buffer, length);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    struct timeval *tm = parcBuffer_Overlay(buffer, sizeof(struct timeval));</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac23fd12b6ae9cff7f1279e8aa3709569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t parcBuffer_ParseDecimalNumber </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ASCII representation of a unsigned decimal number in the given <code>PARCBuffer</code> </p>
<p>The buffer's position will be left at the first non-parsable character.</p>
<p>Overflow is not checked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a valid <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint64_t of the decimal number.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;100&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint64_t value = parcBuffer_ParseDecimalNumber(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7890b44cd73634411efd02cc15afcccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t parcBuffer_ParseHexNumber </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ASCII representation of a hexadecimal number in the given <code>PARCBuffer</code> </p>
<p>The number may be prefixed with the characters '0', 'x'. The buffer's position will be left at the first non-parsable character.</p>
<p>Overflow is not checked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a valid <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint64_t of the hexadecimal number.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;0x10&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint64_t value = parcBuffer_ParseHexNumber(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2b765159d6d59ab7f103fefd5077e0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_ParseHexString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hexString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a null-terminated hexadecimal string to create a new <code>PARCBuffer</code> instance. </p>
<p>The hex string must be null-terminated so parsing is deterministic and correct. The hex string parameter is not modified in any way. The hex string must be an even length greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hexString</td><td>The hex string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL The string could not be parsed </dd>
<dd>
A new <code>PARCElasticBuffer</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *expected = &quot;0123456789ABCDEF&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *buffer = parcBuffer_Flip(parcBuffer_ParseHexString(expected));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    printf(&quot;String: %s\n&quot;, parcBuffer_ToString(buffer));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9711a4f4d3caf5ecc089054cae8ce118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t parcBuffer_ParseNumeric </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ASCII representation of a unsigned decimal number or a hexadecimal number in the given <code>PARCBuffer</code> </p>
<p>The buffer's position will be left at the first non-parsable character.</p>
<p>Overflow is not checked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a valid <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint64_t of the number.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;100&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint64_t value = parcBuffer_ParseNumeric(buffer);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a298e0a6d38751e2f6e4adf077f6afb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parcBuffer_PeekByte </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the byte at the given <code>PARCBuffers'</code> current position, without modifying the position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte at the given <code>PARCBuffers'</code> current position</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_AllocateCString(&quot;Hello&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint8_t byte = parcBuffer_PeekByte(1);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    // byte == (uint8_t) &#39;e&#39;;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a52a85ffe6874ba6e7949898b094dd26d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_Position </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given <code>PARCBuffer</code>'s position. </p>
<p>A buffer's position is the index of the next element to be read or written. A buffer's position is never negative and is never greater than its limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code>'s position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    size_t currentPosition = parcBuffer_Position(buffer);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#aa4bccdf0131a9f4493fe11b6f192be3c" title="Set the given PARCBuffer&#39;s position. ">parcBuffer_SetPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b1619842a21cb0950adf20ee3037c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutArray </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>array</em>[arrayLength]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy <code>arrayLength</code> bytes from the given array into the <code>PARCBuffer</code>. </p>
<p>The position is incremented by <code>arrayLength</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The number of bytes to copy into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A pointer to the array of bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(5);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    uint8_t array[3];</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    array[0] = &#39;A&#39;;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    array[1] = &#39;B&#39;;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    array[2] = &#39;C&#39;;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcBuffer_PutArray(buffer, 3, array);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // the buffer will now contain [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;] at indices 0,1,2</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4588f37d569f1f285e44381ed439ec16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutAtIndex </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert unsigned 8-bit value to the given <code>PARCBuffer</code> at given index. </p>
<p>The buffer's position is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index at which to insert <code>value</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutAtIndex(buffer, 3, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7408ac2d024242c5b767c90e67a59bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutBuffer </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the contents of a <code>PARCBuffer</code> into another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the destination <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>A pointer to the source <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>result</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *insertee = parcBuffer_AllocateCString(&quot;Hello&quot;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_PutBuffer(buffer, insertee);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    // buffer will now contain &quot;Hello&quot; in the first 5 byte indices</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab1dc8eb050d9e4a645b5879b64b839af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutCString </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given nul-terminated C string into a PARCBuffer, including the terminating nul byte. </p>
<p>The position is incremented by the length of the string plus 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>A pointer to nul-terminated C string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>buffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(5);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    char *string = &quot;ABC&quot;;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_PutCString(buffer, string);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // the buffer will now contain [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;, 0] at indices 0, 1, 2, and 3</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac54f8ee661beddf170febf81887657e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutUint16 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an unsigned 16-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order. </p>
<p>Advance the current position by 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to <code>PARCBuffer</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint16(buffer, 0x1234);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab65af61eb5e3949917ef29e0f8c831af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutUint32 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an unsigned 32-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order. </p>
<p>Advance the current position by 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>PARCBuffer</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint32(buffer, 0x12345678);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aee33ab0cac93ea56e86882ce444c9199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutUint64 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an unsigned 64-bit value into the given <code>PARCBuffer</code> at the current position, in big-endian, network-byte-order. </p>
<p>Advance the current position by 8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>PARCBuffer</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint64(buffer, 0x1234);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7a38ecf146eebf75ed88b30a17a96627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_PutUint8 </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an unsigned 8-bit value into the given <code>PARCBuffer</code> at the current position. </p>
<p>Advance the current position by 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to the <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be inserted into the<code>PARCBuffer</code> instance at the current position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>PARCBuffer</code></dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutByte(buffer, &#39;X&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a949677755415fd0448fa465004477951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcBuffer_Release </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer **&#160;</td>
          <td class="paramname"><em>bufferPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the specified instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufferPtr</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa5507d0fcf5bb5671a6242d1ee102faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parcBuffer_Remaining </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements between the current position and the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements remaining in this <code>PARCBuffer</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Remaining(buffer); // Returns 5.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1d6c54a186463fe41919b89ab92fa040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Reset </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the given <code>PARCBuffer</code>'s position to the previously-marked position. </p>
<p>Invoking this method neither changes nor invalidates the mark's value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    buffer = parcBuffer_Reset(buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a36eda11163f5c5bcd1552588bd5a3c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Resize </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase or decrease the capacity of an existing PARCBuffer. </p>
<p>If the new capacity is greater than the old capacity and the limit is currently set to the old capacity, then set the new limit to the new capacity. Otherwise, if the limit is not currently set to the capacity, then leave the limit unchanged.</p>
<p>If the new capacity is less than the old capacity and the limit is currently set to the old capacity, then set the new limit to the new capacity. Otherwise, set the limit to the the lesser of the old limit or the new capacity. If the limit is not currently set to the capacity, the set the limit to the the lesser of the old limit or the new capacity.</p>
<p>If the original mark exceeds the new limit, the new mark is invalidated and any subsequent operation on the resulting <code>PARCBuffer</code> that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code>.</p>
<p>If the original position of the buffer is beyond the new limit of the buffer, the position is set to the new limit.</p>
<p>The contents of the old buffer are preserved from the origin to the new limit.</p>
<p>This operation may induce a memory copy. As a consequence, any <code>PARCBuffer</code> instances previously created via <a class="el" href="parc___buffer_8h.html#a3bd525db9399f7f60512b58b5070aec1">parcBuffer_Slice</a> refer to memory previously used by this <code>PARCBuffer</code>.</p>
<p>A PARCBuffer originally created via any of the <code>parcBuffer_Wrap</code> forms, may no longer refer to the original wrapped data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a valid <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The new capacity of <code>PARCBuffer</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PARCBuffer A new <code>PARCBuffer</code> instance initialized with the contents of the given buffer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;Hello World&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_Resize(buffer, 4);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9" title="Create a new instance of PARCBuffer using dynamically allocated memory. ">parcBuffer_Allocate</a> </dd>
<dd>
<a class="el" href="parc___buffer_8h.html#aefdd97017344b5e2b5ccfe3e37b53b46" title="Create a new instance of PARCBuffer using using program supplied static memory (rather than allocated...">parcBuffer_Wrap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc01b3184924ff1886b2287c19da53b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Rewind </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewinds this <code>PARCBuffer</code>: The position is set to zero and the mark is invalidated. </p>
<p>The mark is made invalid and any subsequent operation on the resulting <code>PARCBuffer</code> that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_Rewind(buffer); // bring it back to zero</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a305130cc27400d15adef57c70b64b9af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_SetLimit </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this <code>PARCBuffer</code>'s limit. </p>
<p>If the position is larger than the new limit then it is set to the new limit.</p>
<p>If the mark is defined and larger than the new limit then the mark is invalidated and any subsequent operation that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">newLimit</td><td>The new limit value; must be no larger than this <code>PARCBuffer</code>'s capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_PutUint8(buffer, (uint8_t)&#39;A&#39;);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcBuffer_SetLimit(buffer, 8);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    size_t limit = parcBuffer_Limit(buffer);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    size_t capacity = parcBuffer_Capacity(buffer);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // capacity is 10, limit is 8</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    ...</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa4bccdf0131a9f4493fe11b6f192be3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_SetPosition </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given <code>PARCBuffer</code>'s position. </p>
<p>A buffer's position is the index of the next element to be read or written. A buffer's position is never negative and is never greater than its limit.</p>
<p>If the mark is defined and larger than the new position then the mark is invalidated and any subsequent operation on the resulting <code>PARCBuffer</code> that requires the mark will abort until the mark is set again via <code>parcBuffer_Mark</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPosition</td><td>The buffer's new position which must be less than or equal to the current limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given <code>PARCBuffer</code>'s position.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Remaining(buffer); // Returns 5.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a85355bd12b92ccf5d867d6435336c2ee" title="Return the given PARCBuffer&#39;s limit. ">parcBuffer_Limit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c0d2b3e02b222e88ec7562ed56ca845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcBuffer_SkipOver </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>bytesToSkipOver</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the position of the given buffer to the first byte that is not in the array <code>bytesToSkipOver</code>. </p>
<p>The position will not exceed the PARCBuffer's limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the byte array that includes skip bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToSkipOver</td><td>A null-terminated array of bytes to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The <code>PARCBuffer</code>'s position was updated. </dd>
<dd>
false The <code>PARCBuffer</code>'s position reached the limit.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;Hello World&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint8_t skipOverBytes[] = { &#39;H&#39;, 0 };</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    bool actual = parcBuffer_SkipOver(buffer, 1, skipOverBytes);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // the buffer position will now be 1, as it skipped over the &#39;H&#39; byte in the array</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // actual will be true</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#af3d5eaf856a13b0d3f6b85c9b6aec305" title="Advance the position of the given buffer to the first byte that is in the array bytesToSkipTo. ">parcBuffer_SkipTo</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3d5eaf856a13b0d3f6b85c9b6aec305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcBuffer_SkipTo </td>
          <td>(</td>
          <td class="paramtype">PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>bytesToSkipTo</em>[length]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the position of the given buffer to the first byte that is in the array <code>bytesToSkipTo</code>. </p>
<p>The position will not exceed the PARCBuffer's limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the byte array that includes skip bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToSkipTo</td><td>A null-terminated array of bytes to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The PARCBuffer's position is at the first byte matched. </dd>
<dd>
false The PARCBuffer's position reached the limit.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;Hello World&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    uint8_t skipOverBytes[] = { &#39;l&#39;, 0 };</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    bool actual = parcBuffer_SkipTo(buffer, 1, skipOverBytes);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // the buffer position will now be set to the index of the first &#39;l&#39; byte in the underlying array</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // actual will be true</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a3c0d2b3e02b222e88ec7562ed56ca845" title="Advance the position of the given buffer to the first byte that is not in the array bytesToSkipOver...">parcBuffer_SkipOver</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bd525db9399f7f60512b58b5070aec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Slice </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new byte buffer whose content is a shared subsequence of this buffer's content. </p>
<p>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</p>
<p>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a new <code>PARCBuffer</code> whose content is a shared subsequence of the original buffer's content. </dd>
<dd>
NULL Memory could not be allocated.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_Allocate(10);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcBuffer_SetPosition(buffer, 5);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_SetLimit(buffer, 8);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    PARCBuffer *slice = parcBuffer_Slice(buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // the slice will be the subset of bytes 5,6,7, and will</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // have limit and capacity of 3 (= 8 - 5)</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ...</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    parcBuffer_Release(&amp;slice);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acb71a7b5cdf2ebc65b16086aa978e668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* parcBuffer_ToHexString </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a null-terminated string containing the hex-byte representation of the given <code>PARCBuffer</code>. </p>
<p>The result must be freed by the caller via <code>parcMemory_Deallocate()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to a <code>PARCBuffer</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL A pointer to an allocated, null-terminated C string that must be deallocated via <a class="el" href="">parcMemory_Deallocate</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *instance = parcBuffer_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    char *hexString = parcBuffer_ToHexString(instance);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcMemory_Deallocate((void **)&amp;hexString);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcBuffer_Release(&amp;instance);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>parcMemory_Deallocate </dd></dl>

</div>
</div>
<a class="anchor" id="a5724719ae25ca858ef0e7c47e617ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* parcBuffer_ToString </td>
          <td>(</td>
          <td class="paramtype">const PARCBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a null-terminated string representation of the specified <code>PARCBuffer</code> from the current position to the limit. </p>
<p>The buffer's position is not changed.</p>
<p>The result must be freed by the caller via <a class="el" href="">parcMemory_Deallocate</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL A pointer to an allocated, null-terminated C string that must be deallocated via <a class="el" href="">parcMemory_Deallocate</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    char *helloWorld = &quot;Hello World&quot;;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCBuffer *instance = parcBuffer_Wrap(helloWorld, strlen(helloWorld), 0, strlen(helloWorld));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    char *string = parcBuffer_ToString(instance);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    if (string != NULL) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        printf(&quot;Hello: %s\n&quot;, string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        parcMemory_Deallocate((void **)&amp;string);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    } else {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        printf(&quot;Cannot allocate memory\n&quot;);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    }</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    parcBuffer_Release(&amp;instance);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#abcf92bf3e11fb90fee53616775bb6cdd" title="Print a human readable representation of the given PARCBuffer. ">parcBuffer_Display</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefdd97017344b5e2b5ccfe3e37b53b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_Wrap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCBuffer</code> using using program supplied static memory (rather than allocated). </p>
<p>The new buffer will be backed by the given array, <code>array</code>. Modifications to the buffer will cause the array to be modified and vice versa.</p>
<p>The new buffer's capacity will be <code>arrayLength</code>, its initial position will be <code>position</code> , the index of the first byte that should not be read or written will be <code>limit</code>, and its mark will be undefined.</p>
<p>In all cases, <em>0 &lt;= position &lt;= limit &lt;= capacity</em></p>
<p>Its backing array will be the given array, starting at index 0 of that array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A pointer to a memory array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The length, in <code>uint8_t</code> units, of the memory array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The initial value for the buffer's position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The initial value for the buffer's limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    uint8_t array[64];</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCBuffer *buffer = parcBuffer_Wrap(array, sizeof(array), 0, sizeof(array));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9" title="Create a new instance of PARCBuffer using dynamically allocated memory. ">parcBuffer_Allocate</a> </dd>
<dd>
<a class="el" href="parc___buffer_8h.html#a949677755415fd0448fa465004477951" title="Release a previously acquired reference to the specified instance, decrementing the reference count f...">parcBuffer_Release</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29390194f5e13b4f2480dfcc8173bc95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_WrapByteArray </td>
          <td>(</td>
          <td class="paramtype">PARCByteArray *&#160;</td>
          <td class="paramname"><em>byteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCBuffer</code> using referencing the given <a class="el" href="">PARCByteArray</a>. </p>
<p>A reference to the <code>PARCByteArray</code> is acquired.</p>
<p>The new buffer will be backed by the given <code>PARCByteArray</code>. Modifications to the buffer will cause the array to be modified and vice versa.</p>
<p>The new buffer's capacity will be <code>arrayLength</code>, its initial position will be <code>position</code> , the index of the first byte that should not be read or written will be <code>limit</code>, and its mark will be undefined.</p>
<p>In all cases, <em>0 &lt;= position &lt;= limit &lt;= capacity</em></p>
<p>The new buffer's capacity will be the length of the <code>PARCByteArray</code>, its initial position will be <code>position</code> , the index of the first byte that should not be read or written will be <code>limit</code>, and its mark will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">byteArray</td><td>A pointer to a <code>PARCByteArray</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The initial value for the buffer's position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The initial value for the buffer's limit which must be less than or equal to the PARCByteArray's capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCByteArray *array = parcByteArray_Allocate(64);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapByteArray(array, 0, parcByteArray_Capacity(array));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcBuffer_Release(&amp;&amp;buffer);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9" title="Create a new instance of PARCBuffer using dynamically allocated memory. ">parcBuffer_Allocate</a> </dd>
<dd>
<a class="el" href="parc___buffer_8h.html#aefdd97017344b5e2b5ccfe3e37b53b46" title="Create a new instance of PARCBuffer using using program supplied static memory (rather than allocated...">parcBuffer_Wrap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad49a2bbb81ceb7ce06dcbb7680a746cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCBuffer* parcBuffer_WrapCString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of <code>PARCBuffer</code> wrapping the given null-terminated C string as its value. </p>
<p>The new buffer's capacity will be the length of the string excluding the terminating nul character. its initial position will be 0, the index of the first byte that should not be read or written will be <code>limit</code>, and its mark will be undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>A pointer to a C-string to copy and then wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>PARCBuffer</code> pointer.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCBuffer *buffer = parcBuffer_WrapCString(&quot;Hello World&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcBuffer_Release(&amp;buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___buffer_8h.html#a26a651a26037477f8f855aebe9e5fce9" title="Create a new instance of PARCBuffer using dynamically allocated memory. ">parcBuffer_Allocate</a> </dd>
<dd>
<a class="el" href="parc___buffer_8h.html#aefdd97017344b5e2b5ccfe3e37b53b46" title="Create a new instance of PARCBuffer using using program supplied static memory (rather than allocated...">parcBuffer_Wrap</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright © 2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Thu Aug 25 2016 12:43:58
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084416; 
var sc_invisible=0;
var sc_security="641a5c50"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" style="width: 2;" src="//c.statcounter.com/11084416/0/641a5c50/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
  </div>
</body>
</html>
