<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>PARC Library: /Users/gscott/Documents/workspace/CCNx_Distillery/src/Libparc/parc/concurrent/parc_FutureTask.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="masthead.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="masthead.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxygen-bootstrap.js"></script>
    </head>
    <body>
        <div class="container masthead">
          <div class="navbar-header">
            <img src="parc_black_solid.png" \>
          </div>
        </div>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">PARC Library </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Public&#160;Types</span></a></li>
      <li><a href="globals.html"><span>Global&#160;Entities</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7f9df3ca38d861d94088e98ccd293ed1.html">Libparc</a></li><li class="navelem"><a class="el" href="dir_32724a6363975856e5331f5a8cd1be3e.html">parc</a></li><li class="navelem"><a class="el" href="dir_c10a46ef759c611f4aa3d2e12d8ef3c2.html">concurrent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parc_FutureTask.h File Reference<div class="ingroups"><a class="el" href="group__threading.html">Threading and Concurrency</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An encapsulated, asynchronous computation.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An encapsulated, asynchronous computation. </p>
<p>This type associates a function and a pointer to data and provides the functionality to invoke the function supplying the given pointer to data and returning the result.</p>
<p>The operations of invoking the function and collecting its return value may be asynchronous from each other in that an attempting to fetch the return value before the function has been invoked will cause the calling thread to block until the function has been invoked and run to completion. This enables the use of PARCFutureTask in a work queue, or thread pool where tasks are run asynchronously from each other and from an originating thread.</p>
<p>Each instance of the type may be cancelled, inhibiting a future invocation of the associated function.</p>
<p>Typical use is a one time invocation of the associated function, induced by the <code>parcFutureTask_Get</code>, but invoking <code>parcFutureTask_GetAndReset</code> invokes the associated function and resets the task to the initial state, permitting a future call to <code>parcFutureTask_Get</code> or <code>parcFutureTask_GetAndReset</code> the run the associated function again.</p>
<dl class="section author"><dt>Author</dt><dd>Glenn Scott, Computing Science Laboratory, PARC </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC). All rights reserved. </dd></dl>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="parc___j_s_o_n_8h_source.html">parc/algol/parc_JSON.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="parc___hash_code_8h_source.html">parc/algol/parc_HashCode.h</a>&gt;</code><br />
<code>#include &lt;parc/concurrent/parc_Timeout.h&gt;</code><br />
<code>#include &lt;<a class="el" href="parc___execution_8h_source.html">parc/algol/parc_Execution.h</a>&gt;</code><br />
</div>
<p><a href="parc___future_task_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_a_r_c_future_task_result.html">PARCFutureTaskResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5a052677d502003b2b94659f6db123cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a052677d502003b2b94659f6db123cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>parcFutureTask_OptionalAssertValid</b>(_instance_)&#160;&#160;&#160;<a class="el" href="parc___future_task_8h.html#a32ed26cd1b558da67da863155dd92e76">parcFutureTask_AssertValid</a>(_instance_)</td></tr>
<tr class="separator:a5a052677d502003b2b94659f6db123cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ed1cf3831b029d48a9ef0769eab8ac1"><td class="memItemLeft" align="right" valign="top">PARCFutureTask *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a6ed1cf3831b029d48a9ef0769eab8ac1">parcFutureTask_Acquire</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a6ed1cf3831b029d48a9ef0769eab8ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of references to a <code>PARCFutureTask</code> instance.  <a href="#a6ed1cf3831b029d48a9ef0769eab8ac1">More...</a><br /></td></tr>
<tr class="separator:a6ed1cf3831b029d48a9ef0769eab8ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ed26cd1b558da67da863155dd92e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a32ed26cd1b558da67da863155dd92e76">parcFutureTask_AssertValid</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a32ed26cd1b558da67da863155dd92e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that the given <code>PARCFutureTask</code> instance is valid.  <a href="#a32ed26cd1b558da67da863155dd92e76">More...</a><br /></td></tr>
<tr class="separator:a32ed26cd1b558da67da863155dd92e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea189ab15e333f0b676e0e6763dd0dc"><td class="memItemLeft" align="right" valign="top">PARCFutureTask *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a7ea189ab15e333f0b676e0e6763dd0dc">parcFutureTask_Create</a> (void *(*runnable)(PARCFutureTask *task, void *parameter), void *parameter)</td></tr>
<tr class="memdesc:a7ea189ab15e333f0b676e0e6763dd0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of <code>PARCFutureTask</code>  <a href="#a7ea189ab15e333f0b676e0e6763dd0dc">More...</a><br /></td></tr>
<tr class="separator:a7ea189ab15e333f0b676e0e6763dd0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0486bfd7a58afa67a1b9a4ae8a587b96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a0486bfd7a58afa67a1b9a4ae8a587b96">parcFutureTask_Compare</a> (const PARCFutureTask *instance, const PARCFutureTask *other)</td></tr>
<tr class="memdesc:a0486bfd7a58afa67a1b9a4ae8a587b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>instance</code> with <code>other</code> for order.  <a href="#a0486bfd7a58afa67a1b9a4ae8a587b96">More...</a><br /></td></tr>
<tr class="separator:a0486bfd7a58afa67a1b9a4ae8a587b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e693aa25ba4c8bed430d3d8194fed9"><td class="memItemLeft" align="right" valign="top">PARCFutureTask *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a57e693aa25ba4c8bed430d3d8194fed9">parcFutureTask_Copy</a> (const PARCFutureTask *original)</td></tr>
<tr class="memdesc:a57e693aa25ba4c8bed430d3d8194fed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an independent copy the given <code>PARCBuffer</code>  <a href="#a57e693aa25ba4c8bed430d3d8194fed9">More...</a><br /></td></tr>
<tr class="separator:a57e693aa25ba4c8bed430d3d8194fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e97c372215a0da872914597b6b0e82b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a2e97c372215a0da872914597b6b0e82b">parcFutureTask_Display</a> (const PARCFutureTask *instance, int indentation)</td></tr>
<tr class="memdesc:a2e97c372215a0da872914597b6b0e82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a human readable representation of the given <code>PARCFutureTask</code>.  <a href="#a2e97c372215a0da872914597b6b0e82b">More...</a><br /></td></tr>
<tr class="separator:a2e97c372215a0da872914597b6b0e82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980837e19c4d9c2f7c74ddef10b4f92d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a980837e19c4d9c2f7c74ddef10b4f92d">parcFutureTask_Equals</a> (const PARCFutureTask *x, const PARCFutureTask *y)</td></tr>
<tr class="memdesc:a980837e19c4d9c2f7c74ddef10b4f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two <code>PARCFutureTask</code> instances are equal.  <a href="#a980837e19c4d9c2f7c74ddef10b4f92d">More...</a><br /></td></tr>
<tr class="separator:a980837e19c4d9c2f7c74ddef10b4f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8781a78fe5cd667f8a5eace57991f0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a8781a78fe5cd667f8a5eace57991f0af">parcFutureTask_HashCode</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a8781a78fe5cd667f8a5eace57991f0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code value for the given instance.  <a href="#a8781a78fe5cd667f8a5eace57991f0af">More...</a><br /></td></tr>
<tr class="separator:a8781a78fe5cd667f8a5eace57991f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511a09b4e4298bdc994f3ea8f1ef0ae8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a511a09b4e4298bdc994f3ea8f1ef0ae8">parcFutureTask_IsValid</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a511a09b4e4298bdc994f3ea8f1ef0ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an instance of <code>PARCFutureTask</code> is valid.  <a href="#a511a09b4e4298bdc994f3ea8f1ef0ae8">More...</a><br /></td></tr>
<tr class="separator:a511a09b4e4298bdc994f3ea8f1ef0ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175cba4b77018924efd6941f1dbc787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a1175cba4b77018924efd6941f1dbc787">parcFutureTask_Release</a> (PARCFutureTask **instancePtr)</td></tr>
<tr class="memdesc:a1175cba4b77018924efd6941f1dbc787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired reference to the given <code>PARCFutureTask</code> instance, decrementing the reference count for the instance.  <a href="#a1175cba4b77018924efd6941f1dbc787">More...</a><br /></td></tr>
<tr class="separator:a1175cba4b77018924efd6941f1dbc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0136a55f3798bfcaf0cdd463d22b1434"><td class="memItemLeft" align="right" valign="top">PARCJSON *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a0136a55f3798bfcaf0cdd463d22b1434">parcFutureTask_ToJSON</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a0136a55f3798bfcaf0cdd463d22b1434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>PARCJSON</code> instance (representation) of the given object.  <a href="#a0136a55f3798bfcaf0cdd463d22b1434">More...</a><br /></td></tr>
<tr class="separator:a0136a55f3798bfcaf0cdd463d22b1434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af97b0a1c16f8e3c04e90567ad36912"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a3af97b0a1c16f8e3c04e90567ad36912">parcFutureTask_ToString</a> (const PARCFutureTask *instance)</td></tr>
<tr class="memdesc:a3af97b0a1c16f8e3c04e90567ad36912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a null-terminated string representation of the specified <code>PARCFutureTask</code>.  <a href="#a3af97b0a1c16f8e3c04e90567ad36912">More...</a><br /></td></tr>
<tr class="separator:a3af97b0a1c16f8e3c04e90567ad36912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa377fb8e23e4670ff3a71c51ea13a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a0fa377fb8e23e4670ff3a71c51ea13a5">parcObject_ImplementNotify</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:a0fa377fb8e23e4670ff3a71c51ea13a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up a single thread that is waiting on this object (see <code>parcFutureTask_Wait)</code>.  <a href="#a0fa377fb8e23e4670ff3a71c51ea13a5">More...</a><br /></td></tr>
<tr class="separator:a0fa377fb8e23e4670ff3a71c51ea13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a3cdd4b137e0ffc22e0f96c7227df2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#ab5a3cdd4b137e0ffc22e0f96c7227df2">parcObject_ImplementNotifyAll</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:ab5a3cdd4b137e0ffc22e0f96c7227df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up all threads that are waiting on the given object's lock.  <a href="#ab5a3cdd4b137e0ffc22e0f96c7227df2">More...</a><br /></td></tr>
<tr class="separator:ab5a3cdd4b137e0ffc22e0f96c7227df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca6cf6a764d8e37215aefca23b3ebcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a2ca6cf6a764d8e37215aefca23b3ebcc">parcObject_ImplementWait</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:a2ca6cf6a764d8e37215aefca23b3ebcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the calling thread to wait until either another thread invokes the parcFutureTask_Notify() function on the same object.  <a href="#a2ca6cf6a764d8e37215aefca23b3ebcc">More...</a><br /></td></tr>
<tr class="separator:a2ca6cf6a764d8e37215aefca23b3ebcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fdea1d01dabe124ba188abbe5b1058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a83fdea1d01dabe124ba188abbe5b1058">parcObject_ImplementLock</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:a83fdea1d01dabe124ba188abbe5b1058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the lock on the given <code>PARCFutureTask</code> instance.  <a href="#a83fdea1d01dabe124ba188abbe5b1058">More...</a><br /></td></tr>
<tr class="separator:a83fdea1d01dabe124ba188abbe5b1058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402fa2e37cf72877957f092b3a4b49a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a402fa2e37cf72877957f092b3a4b49a4">parcObject_ImplementTryLock</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:a402fa2e37cf72877957f092b3a4b49a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to obtain the advisory lock on the given PARCFutureTask instance.  <a href="#a402fa2e37cf72877957f092b3a4b49a4">More...</a><br /></td></tr>
<tr class="separator:a402fa2e37cf72877957f092b3a4b49a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5209730fdddc7a7f714f8f8b1692b70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#ab5209730fdddc7a7f714f8f8b1692b70">parcObject_ImplementUnlock</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:ab5209730fdddc7a7f714f8f8b1692b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to unlock the advisory lock on the given <code>PARCFutureTask</code> instance.  <a href="#ab5209730fdddc7a7f714f8f8b1692b70">More...</a><br /></td></tr>
<tr class="separator:ab5209730fdddc7a7f714f8f8b1692b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592e3c7285c2cacf2f8b96888b1ea6e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a592e3c7285c2cacf2f8b96888b1ea6e0">parcObject_ImplementIsLocked</a> (parcFutureTask, PARCFutureTask)</td></tr>
<tr class="memdesc:a592e3c7285c2cacf2f8b96888b1ea6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the advisory lock on the given <code>PARCFutureTask</code> instance is locked.  <a href="#a592e3c7285c2cacf2f8b96888b1ea6e0">More...</a><br /></td></tr>
<tr class="separator:a592e3c7285c2cacf2f8b96888b1ea6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e431b1b8ea7ae3472d1edcc601d859a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a3e431b1b8ea7ae3472d1edcc601d859a">parcFutureTask_Cancel</a> (PARCFutureTask *task, bool mayInterruptIfRunning)</td></tr>
<tr class="memdesc:a3e431b1b8ea7ae3472d1edcc601d859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cancel the execution of this task.  <a href="#a3e431b1b8ea7ae3472d1edcc601d859a">More...</a><br /></td></tr>
<tr class="separator:a3e431b1b8ea7ae3472d1edcc601d859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3881df0663fc8d70c476e92a7e80dd9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_a_r_c_future_task_result.html">PARCFutureTaskResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a3881df0663fc8d70c476e92a7e80dd9b">parcFutureTask_Get</a> (const PARCFutureTask *futureTask, const <a class="el" href="group__threading.html#gab016c59996801752f553274c7adfc2e8">PARCTimeout</a> *timeout)</td></tr>
<tr class="memdesc:a3881df0663fc8d70c476e92a7e80dd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.  <a href="#a3881df0663fc8d70c476e92a7e80dd9b">More...</a><br /></td></tr>
<tr class="separator:a3881df0663fc8d70c476e92a7e80dd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12b4b50d1faeae6054e748fbc066c8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#aa12b4b50d1faeae6054e748fbc066c8a">parcFutureTask_IsCancelled</a> (const PARCFutureTask *futureTask)</td></tr>
<tr class="memdesc:aa12b4b50d1faeae6054e748fbc066c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this task was cancelled before it completed normally.  <a href="#aa12b4b50d1faeae6054e748fbc066c8a">More...</a><br /></td></tr>
<tr class="separator:aa12b4b50d1faeae6054e748fbc066c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf875ca990701475cee25fcfc8386de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#afaf875ca990701475cee25fcfc8386de">parcFutureTask_IsDone</a> (const PARCFutureTask *futureTask)</td></tr>
<tr class="memdesc:afaf875ca990701475cee25fcfc8386de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this task completed.  <a href="#afaf875ca990701475cee25fcfc8386de">More...</a><br /></td></tr>
<tr class="separator:afaf875ca990701475cee25fcfc8386de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af997d2767410a90213e74d134b45e09e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#af997d2767410a90213e74d134b45e09e">parcFutureTask_Run</a> (PARCFutureTask *futureTask)</td></tr>
<tr class="memdesc:af997d2767410a90213e74d134b45e09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this Future to the result of its computation unless it has been cancelled.  <a href="#af997d2767410a90213e74d134b45e09e">More...</a><br /></td></tr>
<tr class="separator:af997d2767410a90213e74d134b45e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78596115a73e6c0a34c36b4e318fad4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#ae78596115a73e6c0a34c36b4e318fad4">parcFutureTask_RunAndReset</a> (PARCFutureTask *futureTask)</td></tr>
<tr class="memdesc:ae78596115a73e6c0a34c36b4e318fad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled.  <a href="#ae78596115a73e6c0a34c36b4e318fad4">More...</a><br /></td></tr>
<tr class="separator:ae78596115a73e6c0a34c36b4e318fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151069921ae69e3e0ef18f17e18b2640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parc___future_task_8h.html#a151069921ae69e3e0ef18f17e18b2640">parcFutureTask_Reset</a> (PARCFutureTask *task)</td></tr>
<tr class="memdesc:a151069921ae69e3e0ef18f17e18b2640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the given PARCFutureTask to the intial state, a subsequent ecutes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled.  <a href="#a151069921ae69e3e0ef18f17e18b2640">More...</a><br /></td></tr>
<tr class="separator:a151069921ae69e3e0ef18f17e18b2640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6ed1cf3831b029d48a9ef0769eab8ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCFutureTask* parcFutureTask_Acquire </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of references to a <code>PARCFutureTask</code> instance. </p>
<p>Note that new <code>PARCFutureTask</code> is not created, only that the given <code>PARCFutureTask</code> reference count is incremented. Discard the reference by invoking <code>parcFutureTask_Release</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <code>instance</code>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCFutureTask *b = parcFutureTask_Acquire();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcFutureTask_Release(&amp;b);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a32ed26cd1b558da67da863155dd92e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcFutureTask_AssertValid </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that the given <code>PARCFutureTask</code> instance is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcFutureTask_AssertValid(a);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(&quot;Instance is valid.\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcFutureTask_Release(&amp;b);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3e431b1b8ea7ae3472d1edcc601d859a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_Cancel </td>
          <td>(</td>
          <td class="paramtype">PARCFutureTask *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mayInterruptIfRunning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cancel the execution of this task. </p>
<p>This will return <code>false</code> if the task is already done or has already been cancelled. Otherswise, if this task has not started when <code>parcFutureTask_Cancel</code> is called, this task will never run.</p>
<p>If the task is already running, the boolean <code>mayInterruptIfRunning</code> may cause the task to be interrupted, otherwise this function will have no effect.</p>
<p>After this function returns, subsequent calls to <code>parcFutureTask_IsDone</code> will always return true. Subsequent calls to <code>parcFutureTask_isCancelled</code> will always return true if this function returned true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The task was cancelled.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0486bfd7a58afa67a1b9a4ae8a587b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parcFutureTask_Compare </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <code>instance</code> with <code>other</code> for order. </p>
<p>Returns a negative integer, zero, or a positive integer as <code>instance</code> is less than, equal to, or greater than <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 Instance is less than <code>other</code>. </dd>
<dd>
0 Instance a and instance b compare the same. </dd>
<dd>
&gt;0 Instance a is greater than instance b.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCFutureTask *b = parcFutureTask_Create();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (parcFutureTask_Compare(a, b) == 0) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        printf(&quot;Instances are equal.\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcFutureTask_Release(&amp;b);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___future_task_8h.html#a980837e19c4d9c2f7c74ddef10b4f92d" title="Determine if two PARCFutureTask instances are equal. ">parcFutureTask_Equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a57e693aa25ba4c8bed430d3d8194fed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCFutureTask* parcFutureTask_Copy </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an independent copy the given <code>PARCBuffer</code> </p>
<p>A new buffer is created as a complete copy of the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Memory could not be allocated. </dd>
<dd>
non-NULL A pointer to a new <code>PARCFutureTask</code> instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCFutureTask *copy = parcFutureTask_Copy(&amp;b);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcFutureTask_Release(&amp;b);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcFutureTask_Release(&amp;copy);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7ea189ab15e333f0b676e0e6763dd0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCFutureTask* parcFutureTask_Create </td>
          <td>(</td>
          <td class="paramtype">void *(*)(PARCFutureTask *task, void *parameter)&#160;</td>
          <td class="paramname"><em>runnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of <code>PARCFutureTask</code> </p>
<p>If the parameter is an instance of <code>PARCObject</code> a reference to the object will be created and ultimately released via <code>parcFutureTask_Release</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>A pointer to a function to call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>A pointer that will be passed to the function when invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL A pointer to a valid <code>PARCFutureTask</code> instance. </dd>
<dd>
NULL An error occurred.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create(function, parameter);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2e97c372215a0da872914597b6b0e82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcFutureTask_Display </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a human readable representation of the given <code>PARCFutureTask</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid <code>PARCFutureTask</code> instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indentation</td><td>The indentation level to use for printing.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcFutureTask_Display(a, 0);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a980837e19c4d9c2f7c74ddef10b4f92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_Equals </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two <code>PARCFutureTask</code> instances are equal. </p>
<p>The following equivalence relations on non-null <code>PARCFutureTask</code> instances are maintained: *</p><ul>
<li>It is reflexive: for any non-null reference value x, <code>parcFutureTask_Equals(x, x)</code> must return true.</li>
<li>It is symmetric: for any non-null reference values x and y, <code>parcFutureTask_Equals(x, y)</code> must return true if and only if <code>parcFutureTask_Equals(y x)</code> returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if <code>parcFutureTask_Equals(x, y)</code> returns true and <code>parcFutureTask_Equals(y, z)</code> returns true, then <code>parcFutureTask_Equals(x, z)</code> must return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of <code>parcFutureTask_Equals(x, y)</code> consistently return true or consistently return false.</li>
<li>For any non-null reference value x, <code>parcFutureTask_Equals(x, NULL)</code> must return false.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A pointer to a valid PARCFutureTask instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The instances x and y are equal.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    PARCFutureTask *b = parcFutureTask_Create();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    if (parcFutureTask_Equals(a, b)) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        printf(&quot;Instances are equal.\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    parcFutureTask_Release(&amp;b);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___future_task_8h.html#a8781a78fe5cd667f8a5eace57991f0af" title="Returns a hash code value for the given instance. ">parcFutureTask_HashCode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3881df0663fc8d70c476e92a7e80dd9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_a_r_c_future_task_result.html">PARCFutureTaskResult</a> parcFutureTask_Get </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>futureTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__threading.html#gab016c59996801752f553274c7adfc2e8">PARCTimeout</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8781a78fe5cd667f8a5eace57991f0af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parc___hash_code_8h.html#a6a9149819db0ee85c2f8dc474c006705">PARCHashCode</a> parcFutureTask_HashCode </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code value for the given instance. </p>
<p>The general contract of <code>HashCode</code> is:</p>
<p>Whenever it is invoked on the same instance more than once during an execution of an application, the <code>HashCode</code> function must consistently return the same value, provided no information used in a corresponding comparisons on the instance is modified.</p>
<p>This value need not remain consistent from one execution of an application to another execution of the same application. If two instances are equal according to the <a class="el" href="parc___future_task_8h.html#a980837e19c4d9c2f7c74ddef10b4f92d">parcFutureTask_Equals</a> method, then calling the <a class="el" href="parc___future_task_8h.html#a8781a78fe5cd667f8a5eace57991f0af">parcFutureTask_HashCode</a> method on each of the two instances must produce the same integer result.</p>
<p>It is not required that if two instances are unequal according to the <a class="el" href="parc___future_task_8h.html#a980837e19c4d9c2f7c74ddef10b4f92d">parcFutureTask_Equals</a> function, then calling the <code>parcFutureTask_HashCode</code> method on each of the two objects must produce distinct integer results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hashcode for the given instance.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCHashCode hashValue = parcFutureTask_HashCode(buffer);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa12b4b50d1faeae6054e748fbc066c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_IsCancelled </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>futureTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this task was cancelled before it completed normally. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afaf875ca990701475cee25fcfc8386de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_IsDone </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>futureTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this task completed. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;#value#&gt; &lt;#explanation#&gt;</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a511a09b4e4298bdc994f3ea8f1ef0ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_IsValid </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an instance of <code>PARCFutureTask</code> is valid. </p>
<p>Valid means the internal state of the type is consistent with its required current or future behaviour. This may include the validation of internal instances of types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The instance is valid. </dd>
<dd>
false The instance is not valid.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    if (parcFutureTask_IsValid(a)) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        printf(&quot;Instance is valid.\n&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1175cba4b77018924efd6941f1dbc787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcFutureTask_Release </td>
          <td>(</td>
          <td class="paramtype">PARCFutureTask **&#160;</td>
          <td class="paramname"><em>instancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously acquired reference to the given <code>PARCFutureTask</code> instance, decrementing the reference count for the instance. </p>
<p>The pointer to the instance is set to NULL as a side-effect of this function.</p>
<p>If the invocation causes the last reference to the instance to be released, the instance is deallocated and the instance's implementation will perform additional cleanup and release other privately held references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instancePtr</td><td>A pointer to a pointer to the instance to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a151069921ae69e3e0ef18f17e18b2640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parcFutureTask_Reset </td>
          <td>(</td>
          <td class="paramtype">PARCFutureTask *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the given PARCFutureTask to the intial state, a subsequent ecutes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The task was successfully run</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af997d2767410a90213e74d134b45e09e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* parcFutureTask_Run </td>
          <td>(</td>
          <td class="paramtype">PARCFutureTask *&#160;</td>
          <td class="paramname"><em>futureTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this Future to the result of its computation unless it has been cancelled. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result returned by the task function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae78596115a73e6c0a34c36b4e318fad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parcFutureTask_RunAndReset </td>
          <td>(</td>
          <td class="paramtype">PARCFutureTask *&#160;</td>
          <td class="paramname"><em>futureTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled. </p>
<p>&lt;#Paragraphs Of Explanation#&gt;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">[&lt;</td><td class="paramname">in::&gt;</td><td>| &lt;#out#&gt; | &lt;#in,out#&gt;] &lt;#name#&gt; &lt;#description#&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The task was executed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The task was not executed because it was previously completed, or it was cancelled.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;#example#&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0136a55f3798bfcaf0cdd463d22b1434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PARCJSON* parcFutureTask_ToJSON </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>PARCJSON</code> instance (representation) of the given object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Memory could not be allocated to contain the <code>PARCJSON</code> instance. </dd>
<dd>
non-NULL An allocated C string that must be deallocated via parcMemory_Deallocate().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    PARCJSON *json = parcFutureTask_ToJSON(a);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(&quot;JSON representation: %s\n&quot;, parcJSON_ToString(json));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    parcJSON_Release(&amp;json);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3af97b0a1c16f8e3c04e90567ad36912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* parcFutureTask_ToString </td>
          <td>(</td>
          <td class="paramtype">const PARCFutureTask *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a null-terminated string representation of the specified <code>PARCFutureTask</code>. </p>
<p>The result must be freed by the caller via <a class="el" href="">parcMemory_Deallocate</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL Cannot allocate memory. </dd>
<dd>
non-NULL A pointer to an allocated, null-terminated C string that must be deallocated via <a class="el" href="">parcMemory_Deallocate</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    PARCFutureTask *a = parcFutureTask_Create();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    char *string = parcFutureTask_ToString(a);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    parcFutureTask_Release(&amp;a);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    parcMemory_Deallocate(&amp;string);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="parc___future_task_8h.html#a2e97c372215a0da872914597b6b0e82b" title="Print a human readable representation of the given PARCFutureTask. ">parcFutureTask_Display</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a592e3c7285c2cacf2f8b96888b1ea6e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementIsLocked </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the advisory lock on the given <code>PARCFutureTask</code> instance is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The <code>PARCFutureTask</code> is locked. </dd>
<dd>
false The <code>PARCFutureTask</code> is unlocked. Example: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if (parcFutureTask_IsLocked(object)) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        ...</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a83fdea1d01dabe124ba188abbe5b1058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementLock </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the lock on the given <code>PARCFutureTask</code> instance. </p>
<p>If the lock is already held by another thread, this function will block. If the lock is aleady held by the current thread, this function will return <code>false</code>.</p>
<p>Implementors must avoid deadlock by attempting to lock the object a second time within the same calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The lock was obtained successfully. </dd>
<dd>
false The lock is already held by the current thread, or the <code>PARCFutureTask</code> is invalid.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if (parcFutureTask_Lock(object)) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0fa377fb8e23e4670ff3a71c51ea13a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementNotify </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up a single thread that is waiting on this object (see <code>parcFutureTask_Wait)</code>. </p>
<p>If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the underlying implementation.</p>
<p>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if (parcFutureTask_Lock(object)) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        parcFutureTask_Notify(object);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        parcFutureTask_Unlock(object);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab5a3cdd4b137e0ffc22e0f96c7227df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementNotifyAll </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up all threads that are waiting on the given object's lock. </p>
<p>A thread waits on an object by calling one of the wait methods, <code>parcFutureTask_Wait</code>, <code>parcFutureTask_WaitFor</code>, <code>parcFutureTask_WaitUntil</code>. The awakened threads will proceed after the current thread relinquishes the lock on the given object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object. Awakened threads have no priority between them in being the next thread to lock this object.</p>
<p>This method can only be called by a thread that is the owner of this object's lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if (parcFutureTask_Lock(object)) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        parcFutureTask_NotifyAll(object);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        parcFutureTask_Unlock(object);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a402fa2e37cf72877957f092b3a4b49a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementTryLock </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to obtain the advisory lock on the given PARCFutureTask instance. </p>
<p>Once the lock is obtained, the caller must release the lock as soon as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid PARCFutureTask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The PARCFutureTask is locked. </dd>
<dd>
false The PARCFutureTask is unlocked.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcFutureTask_TryLock(object);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab5209730fdddc7a7f714f8f8b1692b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementUnlock </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to unlock the advisory lock on the given <code>PARCFutureTask</code> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The <code>PARCFutureTask</code> was locked and now is unlocked. </dd>
<dd>
false The <code>PARCFutureTask</code> was not locked and remains unlocked.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    parcFutureTask_Unlock(object);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2ca6cf6a764d8e37215aefca23b3ebcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parcObject_ImplementWait </td>
          <td>(</td>
          <td class="paramtype">parcFutureTask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARCFutureTask&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the calling thread to wait until either another thread invokes the parcFutureTask_Notify() function on the same object. </p>
<ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>A pointer to a valid <code>PARCFutureTask</code> instance.</td></tr>
  </table>
  </dd>
</dl>
Example: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    parcFutureTask_Wait(object);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --> </li>
</ul>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
<!--END GENERATE_TREEVIEW-->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
  <div class="container footer">
Copyright © 2008-2016, Xerox Corporation (Xerox) and Palo Alto Research Center, Inc (PARC)<br/>
Thu Aug 25 2016 12:44:00
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
//<![CDATA[
var sc_project=11084416; 
var sc_invisible=0;
var sc_security="641a5c50"; 
var scJsHost = (("https:" == document.location.protocol) ?  "https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter_xhtml.js'></"+"script>");
//]]>
</script>
<noscript>
<div class="statcounter">
<a title="shopify site analytics" href="http://statcounter.com/shopify/" class="statcounter">
<img class="statcounter" style="width: 2;" src="//c.statcounter.com/11084416/0/641a5c50/0/" alt="statcounter" />
</a></div></noscript>
  </div>
<!-- End of StatCounter Code for Default Guide -->
  </div>
</body>
</html>
